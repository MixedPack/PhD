from scipy.optimize import minimizeimport numpy as npfrom astropy.io import fitsimport matplotlib.pyplot as pltfrom numpy.polynomial.polynomial import polyfitimport mathimport pandas as pd#*****************************SAMI Input values**********************************************Galaxies = pd.read_csv('../2_pipeline/0_Galaxies_Table/Galaxies_Table.csv')	FCC_index = Galaxies['FCC']M_r = Galaxies['M_r(mag)']mu_r = Galaxies['mu_r(mag/arcsec2)'] 	#surface brightness calculated with Re in arcsecR_eff = Galaxies['R_e(arcsec)'] * 0.092 			#in kpcKinematics = pd.read_csv('../2_pipeline/0_Kinematics_Table/Kinematics_Table.csv')Velocity = Kinematics['Velocity']Dispersion = Kinematics['Sigma']Vel_error = Kinematics['Error.Velocity']Disp_error = Kinematics['Error.Sigma']#*****************************Replacing Giant SAMIs with Fornax3D results********************F3D = pd.read_csv('../0_data/Literature/F3D.csv')Fobj = F3D['OBJ']Fsigma = F3D['sigma_Re']for j in range(len(FCC_index)):	for k in range(len(Fobj)):		if FCC_index[j] == Fobj[k]:			print(Fobj[k])			Dispersion[j] = Fsigma[k]#*****************************Toloba et al. (2011)**********************************#Toloba et all (2011)Toloba = pd.read_csv('../0_data/Literature/Toloba11.csv')Tsigma = Toloba['sigma']TR_eff = Toloba['R_e'] * 0.0727 #in kpcTSB_e = Toloba['mu_e']TI_e = 10**(-0.4*(TSB_e - 27))#*****************************3d Data***********************************************x = mu_r				#\mu_ey = np.log10(R_eff) 	#logR_ez = np.log10(Dispersion) 	#log\sigma_eA = np.c_[x, y, np.ones(x.shape)]#*****************************Fitting_Least Absolute Deviation*********************************************Y = z.copy()X = A.copy()x0 = [-8.70, 0.70, 12.28]def fit(X, params):    return X.dot(params)def cost_function(params, X, Y):    return np.sum(np.abs(Y - fit(X, params)))    output = minimize(cost_function, x0, args=(X, Y))print(output)Y_hat = fit(X, output.x)#TolobaTY_hat = output.x[0]*TSB_e + output.x[1]*np.log10(TR_eff) +output.x[2]TY = np.log10(Tsigma)#TY_hat = output.x[0]*TSB_e + output.x[1]*np.log10(Tsigma) +output.x[2]#TY = np.log10(TR_eff)fig=  plt.figure(figsize = (20,7))ax = fig.add_subplot(1,1,1)b, m = polyfit(Y, Y_hat, 1)fitline = b + m * Ycm = plt.cm.get_cmap('spring')plt.plot(Y, fitline, c='grey')plt.scatter(TY, TY_hat)plt.scatter(Y, Y_hat, c=SB, s=R_e*20, cmap=cm)cbar = plt.colorbar()cbar.set_label('$\mu_e$ $(mag/arcsec^2)$', rotation=-270)for i in range(len(FCC_index)):	ax.annotate(str(int(FCC_index[i])), (Y[i], Y_hat[i]), fontsize=8)plt.xlabel('log($\sigma_{15}$)')#plt.xlabel('log$R_e$ (kpc)')plt.ylabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log($R_e$) + ' + str("%.2f" % output.x[2]))#plt.ylabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log$\sigma_e$ + ' + str("%.2f" % output.x[2]))plt.savefig("../2_pipeline/3_FP_LAD(SAMI+F3D)/FP_LAD(SAMI+F3D)_x=logS.pdf")#plt.savefig("../2_pipeline/3_FP_LAD(SAMI+F3D)/FP_LAD(SAMI+F3D)_x=logR.pdf")