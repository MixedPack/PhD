from astropy.io import fitsfrom astropy.io import asciifrom plotbin import display_binsfrom plotbin import display_pixelsfrom plotbin import plot_velfieldfrom plotbin import display_bins_generatorsimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport mathimport csvimport matplotlib.gridspec as gridspecfrom pathlib import Path
from astropy.wcs import WCS
from astropy.visualization import (ZScaleInterval, ImageNormalize, LinearStretch)
#************************FUNCTIONS******************************def import_file(index,type=None):		file = "../0_data/SAMI/fcc" + str(int(index)) + "_blue_results_simple_binned(V).fits"	hdulist = fits.open(file)	table = hdulist[1].data	binned_output_V = {"XBIN": table["XBIN"], "YBIN": table["YBIN"], "FLUXBIN": table["FLUXBIN"], 	           "VPXF": table["VPXF"], "SPXF": table["SPXF"]}		file = "../0_data/SAMI/fcc" + str(int(index)) + "_blue_unbinned.fits"	hdulist = fits.open(file)	table = hdulist[1].data	unbinned_output = {"X": table["X"], "Y": table["Y"], "FLUX": table["FLUX"]}		file = "../0_data/SAMI/fcc" + str(int(index)) + "_blue_results_simple_binned(S).fits"	hdulist = fits.open(file)	table = hdulist[1].data	binned_output_S = {"XBIN": table["XBIN"], "YBIN": table["YBIN"], "FLUXBIN": table["FLUXBIN"], 	           "VPXF": table["VPXF"], "SPXF": table["SPXF"]}		if type == None or type == "V":		return (unbinned_output, binned_output_V)	elif type == "S":		return (unbinned_output, binned_output_S)
def get_MinMax_v1(galaxy_index,type=None):		range = ascii.read('../0_data/tmp/V&S_MinMax.txt')		ID = np.where(range["FCC"]==galaxy_index)[0]	vmin = range["VMIN"][ID]	vmax = range["VMAX"][ID]	smin = range["SMIN"][ID]	smax = range["SMAX"][ID]	if type == None or type == "V":		return (vmin, vmax)	elif type == "S":		return (smin, smax)
def get_MinMax_v2(galaxy_index,type=None):		if type == None or type == "V":		data_dict = import_file(galaxy_index, type="V")		binned_data = data_dict[1] 		Bin_Velocity = binned_data["VPXF"] - np.median(binned_data["VPXF"])		RangeMin = np.median(Bin_Velocity)-2*np.std(Bin_Velocity)		RangeMax = np.median(Bin_Velocity)+2*np.std(Bin_Velocity)		Good_Velocity = [Bin_Velocity[i] for i in range(len(Bin_Velocity)) if Bin_Velocity[i] >= RangeMin and Bin_Velocity[i] <= RangeMax]		return (np.median(Good_Velocity)-2*np.std(Good_Velocity), np.median(Good_Velocity)+2*np.std(Good_Velocity))	if type == "S":		data_dict = import_file(galaxy_index, type="S")		binned_data = data_dict[1] 		Bin_Dispersion = binned_data["SPXF"]		RangeMin = np.median(Bin_Dispersion)-2.5*np.std(Bin_Dispersion)		RangeMax = np.median(Bin_Dispersion)+2.5*np.std(Bin_Dispersion)		Good_Dispersion = [Bin_Dispersion[i] for i in range(len(Bin_Dispersion)) if Bin_Dispersion[i] >= RangeMin and Bin_Dispersion[i] <= RangeMax]		return (np.median(Good_Dispersion)-2.5*np.std(Good_Dispersion), np.median(Good_Dispersion)+2.5*np.std(Good_Dispersion))	def velocity_map(galaxy_index):		data_dict = import_file(galaxy_index, type="V")	unbinned_data = data_dict[0]	binned_data = data_dict[1]	VMIN = get_MinMax_v2(galaxy_index,type="V")[0]	VMAX = get_MinMax_v2(galaxy_index,type="V")[1]	ax = display_bins_generators.display_bins_generators(binned_data["XBIN"], binned_data["YBIN"], 	                                     binned_data["VPXF"]-np.median(binned_data["VPXF"]), unbinned_data["X"], unbinned_data["Y"],	                                     vmin=VMIN, vmax=VMAX)
	return axdef dispersion_map(galaxy_index):		data_dict = import_file(galaxy_index, type="S")	unbinned_data = data_dict[0]	binned_data = data_dict[1]	SMIN = get_MinMax_v2(galaxy_index,type="S")[0]		#np.mean(binned_data ["SPXF"])-2*np.std(binned_data ["SPXF"])	SMAX = get_MinMax_v2(galaxy_index,type="S")[1]	ax = display_bins_generators.display_bins_generators(binned_data["XBIN"], binned_data["YBIN"], 	                                   binned_data["SPXF"], unbinned_data["X"], unbinned_data["Y"], 	                                   vmin=SMIN, vmax=SMAX)	#plt.plot(unbinned_data["X"], unbinned_data["Y"], '.')
	return ax
def photometry_image(galaxy_index):
	
	Cubes = pd.read_csv('../0_data/Literature/Cubes_centers.csv')
	IFU = pd.DataFrame({'FCC':Cubes['FCC'] , 'RA':Cubes['x_0'], 'DEC':Cubes['y_0']})	
	X0_SAMI = IFU.RA[IFU.FCC == galaxy_index]
	Y0_SAMI = IFU.DEC[IFU.FCC == galaxy_index]	Galaxies = pd.read_csv('../2_pipeline/0_Galaxies_Table/Galaxies_Table.csv')
	OBJ = pd.DataFrame({'FCC':Galaxies['FCC'] , 'RA':Galaxies['RA(deg)'], 'DEC':Galaxies['DEC(deg)'], 'Re':Galaxies['R_e(arcsec)']})	
	X0_FDS = OBJ.RA[OBJ.FCC == galaxy_index]
	Y0_FDS = OBJ.DEC[OBJ.FCC == galaxy_index]
	Re = OBJ.Re[OBJ.FCC == galaxy_index]
	for i in np.arange(1,33):		
		field_file = '../0_data/Literature/FDS_Photometry_images/r'+str(int(i))+'_cropped.fits.fz'
		my_file = Path(field_file)		if my_file.exists():
			hdu_list = fits.open(field_file)
			image_data = hdu_list[1].data
			wcsHeader = WCS(hdu_list[1].header)
			field_RAmax, field_DECmin = wcsHeader.wcs_pix2world(0,0,0)		#RA is plotted inversely 55->54
			field_RAmin, field_DECmax = wcsHeader.wcs_pix2world(20998,20998,0)					
			if X0_FDS[0] >= field_RAmin and X0_FDS[0] <= field_RAmax and Y0_FDS[0] >= field_DECmin and Y0_FDS[0] <= field_DECmax:		
				print("Found FCC"+str(int(galaxy_index))+" is Field NO."+str(int(i)))				
				print("Field"+i, "RAmin:"+field_RAmin, "RAmax:"+field_RAmax, "DECmin:"+field_DECmin, "DECmax:"+field_DECmax)							
				FDS_pix = wcsHeader.wcs_world2pix(X0_FDS, Y0_FDS, 0)
				fig = plt.figure()
				ax = fig.add_subplot(111, projection=wcsHeader)				
				#v = [FDS_pix[0]-Re*4, FDS_pix[0]+Re*4, FDS_pix[1]-Re*4, FDS_pix[1]+Re*4]
				#ax.axis(v,transform=ax.transAxes)
				norm = ImageNormalize(image_data, ZScaleInterval(), stretch=LinearStretch())
				ax.imshow(image_data, origin='lower', norm=norm, cmap='gray')
				#v = [FDS_pix[0]-Re*4, FDS_pix[0]+Re*4, FDS_pix[1]-Re*4, FDS_pix[1]+Re*4]
				#ax.axis(v,transform=ax.transAxes)
				#SAMI_pix = wcsHeader.wcs_world2pix(X0_SAMI, Y0_SAMI, 0)
				#circle=plt.Circle((SAMI_pix[0], SAMI_pix[1]), 37.5, color='r', fill=False)
				#ax.add_artist(circle)
				#ra = ax.coords[0]
				#ra.set_major_formatter('d.dd')
				#dec = ax.coords[1]
				#dec.set_major_formatter('d.dd')
			else:
				#print("Found FCC"+str(int(galaxy_index))+" is NOT in the field NO."+str(int(i)))
				continue
	return fig#************************MAIN_BODY******************************Galaxies = pd.read_csv('../2_pipeline/0_Galaxies_Table/Galaxies_Table.csv')
OBJ = pd.DataFrame({'FCC':Galaxies['FCC'] , 'RA':Galaxies['RA(deg)'], 'DEC':Galaxies['DEC(deg)'], 'Re':Galaxies['R_e(arcsec)']})	
Cubes = pd.read_csv('../0_data/Literature/Cubes_centers.csv')
IFU = pd.DataFrame({'FCC':Cubes['FCC'] , 'RA':Cubes['x_0'], 'DEC':Cubes['y_0']})	
FCC_index = Galaxies['FCC']	
	
for n in range(len(FCC_index)):	figure = plt.figure(figsize=(20,4))
	
	X0_SAMI = IFU.RA[IFU.FCC == FCC_index[n]]
	Y0_SAMI = IFU.DEC[IFU.FCC == FCC_index[n]]	X0_FDS = OBJ.RA[OBJ.FCC == FCC_index[n]]
	Y0_FDS = OBJ.DEC[OBJ.FCC == FCC_index[n]]
	Re = OBJ.Re[OBJ.FCC == FCC_index[n]]
	
	for i in np.arange(1,33):		
		field_file = '../0_data/Literature/FDS_Photometry_images/r'+str(int(i))+'_cropped.fits.fz'
		my_file = Path(field_file)		if my_file.exists():
			hdu_list = fits.open(field_file)
			image_data = hdu_list[1].data
			wcsHeader = WCS(hdu_list[1].header)			
			field_RAmax, field_DECmin = wcsHeader.wcs_pix2world(0,0,0)		#RA is plotted inversely 55->54
			field_RAmin, field_DECmax = wcsHeader.wcs_pix2world(20998,20998,0)					
			if X0_FDS[0] > field_RAmin and X0_FDS[0] < field_RAmax+1/3600 and Y0_FDS[0] > field_DECmin and Y0_FDS[0] < field_DECmax+1/3600:		
				print("Found FCC"+str(int(FCC_index[n]))+" in Field NO."+str(int(i)))				
				px = figure.add_subplot(141, projection=wcsHeader)				
				FDS_pix = wcsHeader.wcs_world2pix(X0_FDS[0], Y0_FDS[0], 0)
				v = [FDS_pix[0]-Re[0]*4/0.2, FDS_pix[0]+Re[0]*4/0.2, FDS_pix[1]-Re[0]*4/0.2, FDS_pix[1]+Re[0]*4/0.2]
				px.axis(v,transform=px.transAxes)
				norm = ImageNormalize(image_data, ZScaleInterval(), stretch=LinearStretch())
				px.imshow(image_data, origin='lower', norm=norm, cmap='gray')
				SAMI_pix = wcsHeader.wcs_world2pix(X0_SAMI[0], Y0_SAMI[0], 0)
				circle=plt.Circle((SAMI_pix[0], SAMI_pix[1]), 37.5, color='r', fill=False)
				px.add_artist(circle)

			else:
				continue	
	
	vx = plt.subplot(142)	vx = velocity_map(FCC_index[n])
	
	sx = plt.subplot(143)
	sx = dispersion_map(FCC_index[n])	
	plt.show()	figure.savefig("../2_pipeline/1_V&S_Maps/" + str(int(FCC_index[n])) + "Velocity_map.pdf")