from scipy.optimize import minimizeimport numpy as npfrom astropy.io import fitsimport matplotlib.pyplot as pltfrom numpy.polynomial.polynomial import polyfitimport mathimport pandas as pd#x_axis = "log_Sigma"x_axis = "log_Re"errors = 1name = 0reverse = 0exclude = 1
#*****************************SAMI Input values**********************************************if exclude == 1:	Galaxies = pd.read_csv('../2_pipeline/0_Galaxies_Table/Galaxies_Table_EXC.csv')	else:
	Galaxies = pd.read_csv('../2_pipeline/0_Galaxies_Table/Galaxies_Table.csv')
FCC_index = Galaxies['FCC']M_r = Galaxies['M_r(mag)']mu_r = Galaxies['mu_r(mag/arcsec2)'] 	#surface brightness calculated with Re in arcsecR_eff = Galaxies['R_e(arcsec)'] * 0.092 			#in kpcERR_M_r = Galaxies['ERR_m_r(mag)']ERR_mu_r = Galaxies['ERR_mu_r(mag/arcsec2)'] 	#surface brightness calculated with Re in arcsecERR_R_eff = Galaxies['ERR_R_e(arcsec)'] * 0.092 			#in kpcu = Galaxies['u']g = Galaxies['g']COV_mu_logRe = -6.61877e-5if exclude == 1:	Kinematics = pd.read_csv('../2_pipeline/1_Kinematics_Table/Kinematics_Table_EXC.csv')else:
	Kinematics = pd.read_csv('../2_pipeline/1_Kinematics_Table/Kinematics_Table.csv')
Velocity = Kinematics['Velocity']Dispersion = Kinematics['Sigma']Vel_error = Kinematics['Error.Velocity']Disp_error = Kinematics['Error.Sigma']#*****************************separating two kinds of FP*********************************************if x_axis == "log_Sigma":		#*****************************3d Data*************************************************	x = mu_r				#\mu_e	y = np.log10(R_eff) 	#logR_e	z = np.log10(Dispersion) 	#log\sigma_e	A = np.c_[x, y, np.ones(x.shape)]	#*****************************Fitting_Least Absolute Deviation************************	Y = z.copy()	X = A.copy()	x0 = [-8.70, 0.70, 12.28]	def fit(X, params):		return X.dot(params)	#fit function	def cost_function(params, X, Y):		return np.sum(np.abs(Y - fit(X, params)))	#cost function    	output = minimize(cost_function, x0, args=(X, Y))	print(output)	Y_hat = fit(X, output.x)	fig=  plt.figure(figsize = (20,7))	ax = fig.add_subplot(1,1,1)	b, m = polyfit(Y, Y_hat, 1)	fitline = b + m * Y		if reverse == 0:		if errors == 1:			YE = np.zeros(len(FCC_index))			XE = np.zeros(len(FCC_index))			for i in range(len(FCC_index)):				YE[i] = np.sqrt( math.pow(output.x[0]*ERR_mu_r[i],2) + math.pow((output.x[1]/np.log(10))*(ERR_R_eff[i]/R_eff[i]),2) + 2*(output.x[0])*(output.x[1])*COV_mu_logRe )				#YE[i] = np.sqrt( math.pow(output.x[0]*ERR_mu_r[i],2) + math.pow((output.x[1]/np.log(10))*(ERR_R_eff[i]/R_eff[i]),2))				XE[i] = (Disp_error[i])/(Dispersion[i]*np.log(10))		cm = plt.cm.get_cmap('spring')		plt.plot(Y, fitline, c='green')		if errors == 1:			ax.errorbar(Y, Y_hat, yerr=YE, xerr=XE, fmt='.', ecolor='grey')		plt.scatter(Y, Y_hat, c=mu_r, s=R_eff*50, cmap=cm)		cbar = plt.colorbar()		cbar.ax.invert_yaxis() 
		cbar.set_label('$\mu_e$ $(mag/arcsec^2)$', rotation=-270, fontsize=16)		cbar.ax.tick_params(labelsize=16)
		if name == 1:			for i in range(len(FCC_index)):				ax.annotate(str(int(FCC_index[i])), (Y[i], Y_hat[i]), fontsize=12)		plt.xlabel('log($\sigma_{15}$) $(km/s)$', fontsize=18)		plt.ylabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log($R_e$) + ' + str("%.2f" % output.x[2]),fontsize=18)		plt.tick_params(axis='both', which='major', labelsize=16)		
		if exclude == 1:			if errors == 1:				Fname = "FP_LAD_x=logS_error_EXC"			else:				Fname = "FP_LAD_x=logS_EXC"		else:
			if errors == 1:				Fname = "FP_LAD_x=logS_error"			else:				Fname = "FP_LAD_x=logS"
						plt.savefig("../2_pipeline/2_FP_LAD/"+Fname+".pdf")			elif reverse == 1:		if errors == 1:			YE = np.zeros(len(FCC_index))			XE = np.zeros(len(FCC_index))			for i in range(len(FCC_index)):				XE[i] = np.sqrt( math.pow(output.x[0]*ERR_mu_r[i],2) + math.pow((output.x[1]/np.log(10))*(ERR_R_eff[i]/R_eff[i]),2) + 2*(output.x[0])*(output.x[1])*COV_mu_logRe )				#XE[i] = np.sqrt( math.pow(output.x[0]*ERR_mu_r[i],2) + math.pow((output.x[1]/np.log(10))*(ERR_R_eff[i]/R_eff[i]),2))				YE[i] = (Disp_error[i])/(Dispersion[i]*np.log(10))		cm = plt.cm.get_cmap('spring')		plt.plot(fitline, Y, c='green')		if errors == 1:			ax.errorbar( Y_hat, Y, yerr=YE, xerr=XE, fmt='.', ecolor='grey')		plt.scatter(Y_hat, Y, c=mu_r, s=R_eff*50, cmap=cm)		cbar = plt.colorbar()		cbar.ax.invert_yaxis() 
		cbar.set_label('$\mu_e$ $(mag/arcsec^2)$', rotation=-270, fontsize=16)		cbar.ax.tick_params(labelsize=16)		
		if name == 1:			for i in range(len(FCC_index)):				ax.annotate(str(int(FCC_index[i])), (Y_hat[i], Y[i]), fontsize=12)		plt.ylabel('log($\sigma_{15}$) $(km/s)$', fontsize=18)		plt.xlabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log($R_e$) + ' + str("%.2f" % output.x[2]), fontsize=18)		plt.tick_params(axis='both', which='major', labelsize=16)		
		plt.ylim(0.5, 3.0)		if exclude == 1:			if errors == 1:				Fname = "rev_FP_LAD_x=logS_error_EXC"			else:				Fname = "rev_FP_LAD_x=logS_EXC"		else:
			if errors == 1:				Fname = "rev_FP_LAD_x=logS_error"			else:				Fname = "rev_FP_LAD_x=logS"
						plt.savefig("../2_pipeline/2_FP_LAD/"+Fname+".pdf")		
		
		elif x_axis == "log_Re":	print("Chosen log(R_e) as x axis")	#*****************************3d Data*************************************************	x = mu_r					#\mu_e	y = np.log10(Dispersion) 	#log\sigma_e	z = np.log10(R_eff) 		#logR_e	A = np.c_[x, y, np.ones(x.shape)]	#*****************************Fitting_Least Absolute Deviation************************	Y = z.copy()	X = A.copy()	x0 = [-8.70, 0.70, 12.28]	def fit(X, params):		return X.dot(params)	#fit function	def cost_function(params, X, Y):		return np.sum(np.abs(Y - fit(X, params)))	#cost function    	output = minimize(cost_function, x0, args=(X, Y))	print(output)	Y_hat = fit(X, output.x)	fig=  plt.figure(figsize = (20,7))	ax = fig.add_subplot(1,1,1)	b, m = polyfit(Y, Y_hat, 1)	fitline = b + m * Y	if errors == 1:		YE = np.zeros(len(FCC_index))		XE = np.zeros(len(FCC_index))		for i in range(len(FCC_index)):			YE[i] = np.sqrt( math.pow(output.x[0]*ERR_mu_r[i],2) + math.pow((output.x[1]/np.log(10))*(Disp_error[i]/Dispersion[i]),2) )			XE[i] = (ERR_R_eff[i])/(R_eff[i]*np.log(10))	cm = plt.cm.get_cmap('spring')	plt.plot(Y, fitline, c='green')	if errors == 1:		ax.errorbar(Y, Y_hat, yerr=YE, xerr=XE, fmt='.', ecolor='grey')	plt.scatter(Y, Y_hat, c=mu_r, s=R_eff*50, cmap=cm)	cbar = plt.colorbar()	cbar.ax.invert_yaxis() 
	cbar.set_label('$\mu_e$ $(mag/arcsec^2)$', rotation=-270, fontsize=16)
	cbar.ax.tick_params(labelsize=16)	if name == 1:		for i in range(len(FCC_index)):			ax.annotate(str(int(FCC_index[i])), (Y[i], Y_hat[i]), fontsize=12)	plt.xlabel('log($R_e$) (kpc)', fontsize=18)	plt.ylabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log($\sigma_{15}$) + ' + str("%.2f" % output.x[2]), fontsize=18)	plt.tick_params(axis='both', which='major', labelsize=16)	
	#plt.ylim(-0.65, 1.25)	#plt.xlim(-0.55, 1.2)	
	if exclude == 1:		if errors == 1:			Fname = "FP_LAD_x=logR_error_EXC"		else:			Fname = "FP_LAD_x=logR_EXC"	else:
		if errors == 1:			Fname = "FP_LAD_x=logR_error"		else:			Fname = "FP_LAD_x=logR"
						plt.savefig("../2_pipeline/2_FP_LAD/"+Fname+".pdf")#*****Two disk galaxies********#folder = '../../Galaxies_Table/Galaxies_Table_Disks.txt'	#inputs = np.loadtxt(folder,skiprows=2)#Index = inputs[:,0]#SurfBright = inputs[:,6]#Radius = inputs[:,7]#Sig_B = np.zeros(len(Index))#for i in range(len(Index)):#	file = 'fcc'+str(int(Index[i]))+'_blue_results'+'.fits'#	HD = fits.open("../../../SAMI/Blue_Cubes/results_values/One_Bin/Simple/15arcsec/"+file)#	Data = HD['STEKIN'].data#	Sig_B[i] = np.mean(Data['SPXF'])#XX = np.log10(Sig_B)#YY = output.x[0]*SurfBright + output.x[1]*np.log10(Radius) + output.x[2]#ax.plot(XX,YY, 'x', color='Blue')#for i in range(len(Index)):#	ax.annotate(str(int(Index[i])), (XX[i], YY[i]), fontsize=8)