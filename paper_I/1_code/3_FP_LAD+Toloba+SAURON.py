from scipy.optimize import minimizeimport numpy as npfrom astropy.io import fitsimport matplotlib.pyplot as pltfrom numpy.polynomial.polynomial import polyfitimport mathimport pandas as pd#x_axis = "log_Sigma"x_axis = "log_Re"name = 1residuals = 0reverse = 1#*****************************Input values**********************************************Galaxies = pd.read_csv('../2_pipeline/0_Galaxies_Table/Galaxies_Table.csv')	FCC_index = Galaxies['FCC']M_r = Galaxies['M_r(mag)']mu_r = Galaxies['mu_r(mag/arcsec2)'] 	#surface brightness calculated with Re in arcsecR_eff = Galaxies['R_e(arcsec)'] * 0.092 			#in kpcKinematics = pd.read_csv('../2_pipeline/1_Kinematics_Table/Kinematics_Table.csv')Velocity = Kinematics['Velocity']Dispersion = Kinematics['Sigma']Vel_error = Kinematics['Error.Velocity']Disp_error = Kinematics['Error.Sigma']#*****************************Toloba et al. (2011)**********************************#Toloba et all (2011)Toloba = pd.read_csv('../0_data/Literature/Toloba11.csv')TDisper = Toloba['Dispersion']TR_eff = Toloba['R_e'] * 0.0727 #in kpcTmu_V_e = Toloba['mu_V_e']ColB_V = Toloba['E(B-V)']Colg_V = 0.630*ColB_V - 0.124Colg_r = (-1 * Colg_V + 0.016)/(-0.565)Colr_V = Colg_V - Colg_r#TM_r = TM_V + Colr_VTmu_r_e = Tmu_V_e + Colr_V#*****************************SAURON project**********************************#Toloba et all (2011)SAURON = pd.read_csv('../0_data/Literature/SAURONproject.csv')SDisper = SAURON['Dispersion (km/s)']Sm_M = SAURON['(m-M) (mag)']SR_eff = 0.01 * math.power(10, Sm_M/5) 	#in kpcSM_B = SAURON['M_B (mag)']Smu_?[l] = tbdata_FDS.field('r_mag')[j] + 2.5 * np.log10(math.pi*axis_ratio[l]*math.pow(R_eff[l],2)) + 2.5 * np.log10(2)#*****************************3d Data***********************************************if x_axis == "log_Sigma":	x = mu_r  # \mu_e	y = np.log10(R_eff)  # logR_e	z = np.log10(Dispersion)  # log\sigma_eelif x_axis == "log_Re":	x = mu_r  # \mu_e	y = np.log10(Dispersion)  # log\sigma_e	z = np.log10(R_eff)  # logR_eA = np.c_[x, y, np.ones(x.shape)]#*****************************Fitting_Least Absolute Deviation*********************************************Y = z.copy()X = A.copy()x0 = [-8.70, 0.70, 12.28]def fit(X, params):    #print("----fit function")    #print(params)    return X.dot(params)def cost_function(params, X, Y):    #print("----cost function")    #print(params)    return np.sum(np.abs(Y - fit(X, params)))    output = minimize(cost_function, x0, args=(X, Y))print(output)Y_hat = fit(X, output.x)#Tolobaif x_axis == "log_Sigma":	TY_hat = output.x[0]*Tmu_r_e + output.x[1]*np.log10(TR_eff) +output.x[2]	TY = np.log10(TDisper)elif x_axis == "log_Re":	TY_hat = output.x[0]*Tmu_r_e + output.x[1]*np.log10(TDisper) +output.x[2]	TY = np.log10(TR_eff)fig=  plt.figure(figsize = (20,7))ax = fig.add_subplot(1,1,1)b, m = polyfit(Y, Y_hat, 1)fitline = b + m * Ycm = plt.cm.get_cmap('spring')plt.plot(Y, fitline, c='grey')plt.scatter(TY, TY_hat)plt.scatter(Y, Y_hat, c=mu_r, s=R_eff*20, cmap=cm)cbar = plt.colorbar()cbar.set_label('$\mu_e$ $(mag/arcsec^2)$', rotation=-270)if name == 1:	for i in range(len(FCC_index)):		ax.annotate(str(int(FCC_index[i])), (Y[i], Y_hat[i]), fontsize=8)if x_axis == "log_Sigma":	plt.xlabel('log($\sigma_{15}$)')	plt.ylabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log($R_e$) + ' + str("%.2f" % output.x[2]))elif x_axis == "log_Re":	plt.xlabel('log$R_e$ (kpc)')	plt.ylabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log$\sigma_e$ + ' + str("%.2f" % output.x[2]))#*****Two disk galaxies********#folder = '../../Galaxies_Table/Galaxies_Table_Disks.txt'	#inputs = np.loadtxt(folder,skiprows=2)#Index = inputs[:,0]#SurfBright = inputs[:,6]#Radius = inputs[:,7]#Sig_B = np.zeros(len(Index))#for i in range(len(Index)):#	file = 'fcc'+str(int(Index[i]))+'_blue_results'+'.fits'#	HD = fits.open("../../../SAMI/Blue_Cubes/results_values/One_Bin/Simple/15arcsec/"+file)#	Data = HD['STEKIN'].data#	Sig_B[i] = np.mean(Data['SPXF'])#XX = np.log10(Sig_B)#YY = output.x[0]*SurfBright + output.x[1]*np.log10(Radius) + output.x[2]#ax.plot(XX,YY, 'x', color='Blue')#for i in range(len(Index)):#	ax.annotate(str(int(Index[i])), (XX[i], YY[i]), fontsize=8)if x_axis == "log_Sigma":	plt.savefig("../2_pipeline/3_FP_LAD+Toloba/FP_LAD+Toloba_x=logS.pdf")elif x_axis == "log_Re":	plt.savefig("../2_pipeline/3_FP_LAD+Toloba/FP_LAD+Toloba_x=logR.pdf")#********************************Residuals********************************************if residuals == 1:	def Residual(i):		return np.abs(Y[i] - fit(X[i], params))/np.sqrt(params[0]**2+params[1]**2+1)	params = output.x	RS = [Residual(i) for i in range(len(X))]	out_file = open('./Residuals.txt', 'w+')	out_file.write("FCC" + "\t" + "Residual" + "\n")	for i in range(len(RS)):		out_file.write( str(int(FCC_index[i])) + "\t " + str(RS[i]) + "\n" )	out_file.close()	def plot_fun(i, x, y, reverse = None):		ax = fig.add_subplot(2,2,i)		ax.plot(x, y,'.')		plt.ylabel('Perpendicular Residual')		if reverse != None:			plt.gca().invert_xaxis()		for i in range(len(FCC_index)):			ax.annotate(str(int(FCC_index[i])), (x[i], y[i]), fontsize=8)	fig =  plt.figure(figsize = (20,10))	plot_fun(1, np.log10(SB), RS, reverse=1)	plt.xlabel('log$<\mu_e>$')	plot_fun(2, np.log10(R_e), RS)	plt.xlabel('log$R_e$')	plot_fun(3, np.log10(S_B), RS)	plt.xlabel('log$\sigma_e$')	plot_fun(4, M_r, RS, reverse=1)	plt.xlabel('$M_r$')	plt.savefig('Residuals_Comparison.pdf')