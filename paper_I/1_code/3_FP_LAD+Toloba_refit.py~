from scipy.optimize import minimizeimport numpy as npfrom astropy.io import fitsimport matplotlib.pyplot as pltfrom numpy.polynomial.polynomial import polyfitimport mathimport pandas as pd# x_axis = "log_Sigma"x_axis = "log_Re"name = 0residuals = 0reverse = 1# *****************************Input values**********************************************Galaxies = pd.read_csv('../2_pipeline/0_Galaxies_Table/Galaxies_Table.csv')FCC_index = Galaxies['FCC']M_r = Galaxies['M_r(mag)']mu_r = Galaxies['mu_r(mag/arcsec2)']  # surface brightness calculated with Re in arcsecR_eff = Galaxies['R_e(arcsec)'] * 0.092  # in kpcKinematics = pd.read_csv('../2_pipeline/1_Kinematics_Table/Kinematics_Table.csv')Velocity = Kinematics['Velocity']Dispersion = Kinematics['Sigma']Vel_error = Kinematics['Error.Velocity']Disp_error = Kinematics['Error.Sigma']# *****************************Toloba et al. (2011)**********************************# Toloba et all (2011)Toloba = pd.read_csv('../0_data/Literature/Toloba11.csv')TDisper = Toloba['Dispersion']TR_eff = Toloba['R_e'] * 0.0727  # in kpcTmu_V_e = Toloba['mu_V_e']ColB_V = Toloba['E(B-V)']Colg_V = 0.630 * ColB_V - 0.124Colg_r = (-1 * Colg_V + 0.016) / (-0.565)Colr_V = Colg_V - Colg_rTmu_r_e = Tmu_V_e + Colr_V# *************************** appending two sets of data *******************************All_Disper = pd.concat([Dispersion,TDisper])All_R_eff = pd.concat([R_eff,TR_eff])All_mu_r = pd.concat([mu_r, Tmu_r_e])# *****************************3d Data***********************************************if x_axis == "log_Sigma":    x = All_mu_r  # \mu_e    y = np.log10(All_R_eff)  # logR_e    z = np.log10(All_Disper)  # log\sigma_eelif x_axis == "log_Re":    x = All_mu_r  # \mu_e    y = np.log10(All_Disper)  # log\sigma_e    z = np.log10(All_R_eff)  # logR_eA = np.c_[x, y, np.ones(x.shape)]# *****************************Fitting_Least Absolute Deviation*********************************************Y = z.copy()X = A.copy()x0 = [-8.70, 0.70, 12.28]def fit(X, params):    return X.dot(params)                # fit functiondef cost_function(params, X, Y):    return np.sum(np.abs(Y - fit(X, params)))   #cost functionoutput = minimize(cost_function, x0, args=(X, Y))print(output)Y_hat = fit(X, output.x)fig = plt.figure(figsize=(20, 7))ax = fig.add_subplot(1, 1, 1)b, m = polyfit(Y, Y_hat, 1)fitline = b + m * Ycm = plt.cm.get_cmap('spring')plt.plot(Y, fitline, c='grey')plt.scatter(Y, Y_hat, c=All_mu_r, s=All_R_eff * 20, cmap=cm)cbar = plt.colorbar()cbar.set_label('$\mu_e$ $(mag/arcsec^2)$', rotation=-270)if name == 1:    for i in range(len(FCC_index)):        ax.annotate(str(int(FCC_index[i])), (Y[i], Y_hat[i]), fontsize=8)if x_axis == "log_Sigma":    plt.xlabel('log($\sigma_{15}$)')    plt.ylabel(str("%.2f" % output.x[0]) + ' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log($R_e$) + ' + str(        "%.2f" % output.x[2]))elif x_axis == "log_Re":    plt.xlabel('log$R_e$ (kpc)')    plt.ylabel(str("%.2f" % output.x[0]) + ' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log$\sigma_e$ + ' + str(        "%.2f" % output.x[2]))if x_axis == "log_Sigma":    plt.savefig("../2_pipeline/3_FP_LAD+Toloba_refit/FP_LAD+Toloba_x=logS_refit.pdf")elif x_axis == "log_Re":    plt.savefig("../2_pipeline/3_FP_LAD+Toloba_refit/FP_LAD+Toloba_x=logR_refit.pdf")