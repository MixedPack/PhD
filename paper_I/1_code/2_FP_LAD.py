from scipy.optimize import minimizeimport numpy as npfrom astropy.io import fitsimport matplotlib.pyplot as pltfrom numpy.polynomial.polynomial import polyfitimport mathimport pandas as pd#*****************************Input values**********************************************#input galaxies' propertiesfolder = '../2_pipeline/0_Galaxies_Table/Galaxies_Table.csv'	Galaxies = np.loadtxt(folder,skiprows=1)FCC_index = Galaxies[:,0]M_r = Galaxies[:,5]mu_r = Galaxies[:,6] #surface brightness calculated with Re in arcsecR_eff = Galaxies[:,7] * 0.092 #in kpc#folder_err = '../../Galaxies_Table/Galaxies_Table_error.txt'#input_errors = np.loadtxt(folder_err,skiprows=2)#SB_err = input_errors[:,4]#Re_err = input_errors[:,6]Kinematics = pd.read_csv('../2_pipeline/1_Kinematics_Table/Kinematics_Table.csv')Velocity = Kinematics['Velocity']Dispersion = Kinematics['Sigma']Vel_error = Kinematics['Error.Velocity']Disp_error = Kinematics['Error.Sigma']#*****************************3d Data***********************************************x = mu_r				#\mu_ey = np.log10(R_eff) 	#logR_ez = np.log10(Dispersion) 	#log\sigma_eA = np.c_[x, y, np.ones(x.shape)]#*****************************Fitting_Least Absolute Deviation*********************************************Y = z.copy()X = A.copy()x0 = [-8.70, 0.70, 12.28]def fit(X, params):    #print("----fit function")    #print(params)    return X.dot(params)def cost_function(params, X, Y):    #print("----cost function")    #print(params)    return np.sum(np.abs(Y - fit(X, params)))    output = minimize(cost_function, x0, args=(X, Y))print(output)Y_hat = fit(X, output.x)fig=  plt.figure(figsize = (20,7))ax = fig.add_subplot(1,1,1)b, m = polyfit(Y, Y_hat, 1)fitline = b + m * Y#YE = np.zeros(len(R_e))#for i in range(len(R_e)):	#YE[i] = np.sqrt( math.pow((output.x[0]/np.log(10))*(Re_err[i]/R_e[i]),2) + math.pow((output.x[1]/np.log(10))*(SB_err[i]/SB[i]),2) + 2*(output.x[0]/np.log(10))*(Re_err[i]/R_e[i])*(output.x[1]/np.log(10))*(SB_err[i]/SB[i]))#	YE[i] = (output.x[0]/np.log(10))*(Re_err[i]/R_e[i]) + (output.x[1])*(SB_err[i])#XE = (Disp_error)/(S_B*np.log(10))cm = plt.cm.get_cmap('spring')plt.plot(Y, fitline, c='grey')#ax.errorbar(Y, Y_hat, yerr=YE, xerr=XE, fmt='.', ecolor='green')plt.scatter(Y, Y_hat, c=mu_r, s=R_eff*20, cmap=cm)cbar = plt.colorbar()cbar.set_label('$\mu_e$ $(mag/arcsec^2)$', rotation=-270)for i in range(len(FCC_index)):	ax.annotate(str(int(FCC_index[i])), (Y[i], Y_hat[i]), fontsize=8)plt.xlabel('log($\sigma_{15}$)')#plt.xlabel('log$R_e$ (kpc)')plt.ylabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log($R_e$) + ' + str("%.2f" % output.x[2]))#plt.ylabel(str("%.2f" % output.x[0])+' $<\mu_e>$ + ' + str("%.2f" % output.x[1]) + ' log$\sigma_e$ + ' + str("%.2f" % output.x[2]))#*****Two disk galaxies********#folder = '../../Galaxies_Table/Galaxies_Table_Disks.txt'	#inputs = np.loadtxt(folder,skiprows=2)#Index = inputs[:,0]#SurfBright = inputs[:,6]#Radius = inputs[:,7]#Sig_B = np.zeros(len(Index))#for i in range(len(Index)):#	file = 'fcc'+str(int(Index[i]))+'_blue_results'+'.fits'#	HD = fits.open("../../../SAMI/Blue_Cubes/results_values/One_Bin/Simple/15arcsec/"+file)#	Data = HD['STEKIN'].data#	Sig_B[i] = np.mean(Data['SPXF'])#XX = np.log10(Sig_B)#YY = output.x[0]*SurfBright + output.x[1]*np.log10(Radius) + output.x[2]#ax.plot(XX,YY, 'x', color='Blue')#for i in range(len(Index)):#	ax.annotate(str(int(Index[i])), (XX[i], YY[i]), fontsize=8)plt.savefig("../2_pipeline/2_FP_LAD/FP_LAD.pdf")#********************************Residuals********************************************def Residual(i):    return np.abs(Y[i] - fit(X[i], params))/np.sqrt(params[0]**2+params[1]**2+1)params = output.xRS = [Residual(i) for i in range(len(X))]#out_file = open('./Residuals.txt', 'w+')out_file.write("FCC" + "\t" + "Residual" + "\n")for i in range(len(RS)):	out_file.write( str(int(FCC_index[i])) + "\t " + str(RS[i]) + "\n" )out_file.close()def plot_fun(i, x, y, reverse = None):	ax = fig.add_subplot(2,2,i)	ax.plot(x, y,'.')	plt.ylabel('Perpendicular Residual')	if reverse != None:		plt.gca().invert_xaxis()	for i in range(len(FCC_index)):		ax.annotate(str(int(FCC_index[i])), (x[i], y[i]), fontsize=8)fig =  plt.figure(figsize = (20,10))plot_fun(1, np.log10(SB), RS, reverse=1)plt.xlabel('log$<\mu_e>$')plot_fun(2, np.log10(R_e), RS)plt.xlabel('log$R_e$')plot_fun(3, np.log10(S_B), RS)plt.xlabel('log$\sigma_e$')plot_fun(4, M_r, RS, reverse=1)plt.xlabel('$M_r$')#plt.savefig('Residuals_Comparison.pdf')            